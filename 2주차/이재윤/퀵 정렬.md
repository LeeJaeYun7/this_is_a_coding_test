

```
## 퀵 정렬
- 퀵 정렬은 지금까지 배운 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다.
  이 책에서 다루지는 않지만, 퀵 정렬과 비교할 만큼 빠른 알고리즘으로 '병합 정렬' 알고리즘이다.
  이 두 알고리즘은 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 하다. 
  
  그렇다면 퀵 정렬은 도대체 어떻게 동작하길래 이름부터가 '빠른 정렬 알고리즘'인지 알아보자.
  
  '기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?'
  
  퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
  이해하기까지 시간이 걸리겠지만, 원리를 이해하면 병합 정렬, 힙 정렬 등 다른 고급 정렬 기법에 비해
  쉽게 소스코드를 작성할 수 있다. 
  
  퀵 정렬에서는 피벗(pivot)이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 표현한다.
  퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다. 
  피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬을 구분하는데,
  책에서는 가장 대표적인 분할 방식인 호어 분할(Hoare Partition) 방식을 기준으로 퀵 정렬을 설명하겠다. 
  호어 분할 방식에서는 다음과 같은 규칙에 따라서 피벗을 설정한다. 
  
  - 리스트에서 첫 번째 데이터를 피벗으로 정한다. 
  
  이와 같이 피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.
  그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 
  이러한 과정을 반복하면 '피벗'에 대하여 정렬이 수행된다.
  자세한 과정은 그림으로 살펴보며 이해해보자. 
  
  다음과 같이 초기 데이터가 구성되어 있다고 가정해보자.
  5, 7, 9, 0, 3, 1, 6, 2, 4, 8 
  
  퀵 정렬은 전체를 3개의 파트로 나눠서 보는 게 편하다. 편의상 1,2,3 파트로 나눠서 보겠다. 
  
  1파트
  - 리스트의 첫 번째 데이터를 피벗으로 설정하므로 피벗은 '5'이다. 
    이후에 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로, '7'이 선택되고,
    오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택된다. 
    이제 이 두 데이터의 위치를 서로 변경한다. 
  
  - 그 다음 다시 피벗보다 큰 데이터와 작은 데이터를 각각 찾는다.
    찾은 뒤에는 두 값의 위치를 서로 변경하는데, 현재 '9'와 '2'가 선택되었으므로,
    이 두 데이터의 위치를 서로 변경한다. 
    
  - 그 다음 다시 피벗보다 큰 데이터와 작은 데이터를 찾는다.
    단, 현재 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 서로 엇갈린 것을 알 수 있다.
    이렇게 두 값이 엇갈린 경우에는 '작은 데이터'와 '피벗'의 위치를 서로 변경한다.
    즉, 작은 데이터인 '1'과 피벗인 '5'의 위치를 서로 변경하여 분할을 수행한다.
    
  - 분할 완료: 이와 같이 피벗이 이동한 상태에서 왼쪽 리스트와 오른쪽 리스트를 살펴보자.
               이제 '5'의 왼쪽에 있는 데이터는 모두 '5'보다 작고,
               오른쪽에 있는 데이터는 모두 '5'보다 크다는 특징이 있다.
               이렇게 피벗의 왼쪽에는 피벗보다 작은 데이터가 위치하고, 
               피벗의 오른쪽에는 피벗보다 큰 데이터가 위치하도록 하는 작업을 분할 혹은 파티션이라고 한다.
            
  - 이러한 상태에서 왼쪽 리스트와 오른쪽 리스트를 개별적으로 정렬시키면 어떨까?
    어차피 왼쪽 리스트는 어떻게 정렬되어도 모든 데이터가 '5'보다 작다. 
    마찬가지로 오른쪽 리스트 또한 어떻게 정렬되어도 모든 데이터가 '5'보다 크다.
    따라서 왼쪽 리스트와 오른쪽 리스트에서도 각각 피벗을 설정하여 동일한 방식으로 정렬을 수행하면
    전체 리스트에 대하여 모두 정렬이 이루어질 것이다. 
    
  2파트
  - 왼쪽 리스트에서는 다음 그림과 같이 정렬이 진행되며 구체적인 정렬 과정은 동일하다.
    
  3파트
  - 오른쪽 리스트에서는 다음 그림과 같이 정렬이 진행되며 구체적인 정렬 과정은 동일하다. 
  
  - 이 과정은 종이를 잘라 숫자를 적은 다음에 직접 한 번 해보기를 권한다.
    그러면 더 빠르게 이해할 수 있으리라 본다.
    퀵 정렬에서는 이처럼 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후에,
    피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬을 수행한다. 
    5장에서 다루었던 '재귀 함수'와 동작 원리가 같다.
    실제로 퀵 정렬은 재귀 함수 형태로 작성했을 때 구현이 매우 간결해진다.
    
  - 재귀 함수와 동작 원리가 같다면, 종료 조건도 있어야 할 것이다.
    퀵 정렬이 끝나는 조건은 언제일까?
    바로 현재 리스트의 데이터 개수가 1개인 경우이다.
    리스트의 원소가 1개라면, 이미 정렬이 되어 있다고 간주할 수 있으며,
    분할이 불가능하다.
    
  - 따라서 이러한 과정을 전체적으로 살펴보면 다음과 같이 정리할 수 있다.
    퀵 정렬을 처음 접한 독자라면 다음 그림에서의 분할 과정을 곧바로 이해하기는 쉽지 않겠지만,
    곧이어 등장할 소스코드와 함께 살펴보면 비로소 이해할 수 있을 것이다. 
    
    다음 소스코드 형태는 널리 사용되고 있는 가장 직관적인 형태의 퀵 정렬 소스코드다. 
    
    


```
