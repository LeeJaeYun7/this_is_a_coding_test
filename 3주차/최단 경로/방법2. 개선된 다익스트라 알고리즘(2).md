
```
개선된 다익스트라 알고리즘의 시간 복잡도

- 앞서 배웠던 간단한 다익스트라 알고리즘에 비해 개선된 다익스트라 알고리즘은
  시간 복잡도가 O(ElogN)로 훨씬 빠르다.
  하지만 직관적으로 봤을 때, 이처럼 우선순위 큐를 이용하는 방식이 훨씬 빠른 이유에 대해서
  잘 납득이 가지 않을 수 있다. 

- 우리의 코드에서도 확인할 수 있듯이 한 번 처리된 노드는 더 이상 처리되지 않는다.
   다시 말해 큐에서 노드를 하나씩 꺼내 검사하는 반복문(while문)은 
   노드의 개수 V 이상의 횟수로는 반복되지 않는다.
   또한 V번 반복될 때마다 각각 자신과 연결된 간선들을 모두 확인한다.
   따라서 '현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인'하는 총 횟수는
   총 최대 간선의 개수(E)만큼 연산이 수행될 수 있다.

- 따라서 전체 다익스트라 최단 경로 알고리즘은 E개의 원소를 우선순위 큐에 넣었다가
   모두 빼내는 연산과 매우 유사하다고 볼 수 있다.
   앞에서 말했듯이 힙에 N개의 데이터를 모두 넣고, 이후에 모두 빼는 과정은 
   O(NlogN)이다.
   간단하게 생각하면 다익스트라 알고리즘의 시간 복잡도는 최대 E개의 간선 데이털르
   힙에 넣었다가 다시 빼는 것으로 볼 수 있으므로 O(ElogE)임을 이해할 수 있다.

- 이 때, 중복 간선을 포함하지 않는 경우 ,E는 항상 V2보다 작다.
   왜냐하면 모든 노드끼리 서로 다 연결되어 있다고 했을 때, 
   간선의 개수를 약 V2으로 볼 수 있고 E는 항상 V2이하이기 때문이다. 
   다시 말해 logE는 logV2보다 작다. 이 때 O(logV2)은 O(2logV)이고, 
   이는 O(logV)이다. 따라서 다익스트라 알고리즘의 전체 시간 복잡도를 간단히
   O(ElogV)라고 볼 수 있다. 

- 현재 소스코드에서는 우선순위 큐의 개념이 들어가므로 시간 복잡도 계산을 바로
   이해하기엔 어렵겠지만, 천천히 생각해보면 이해할 수 있을 것이다. 
   시간 복잡도 개념을 제대로 이해하지 못해도 최소한 다익스트라 최단 경로 알고리즘의
   소스코드만 잘 기억해두자. 그러면 최단 경로 문제를 풀 수 있으며
   많은 문제를 풀다보면 결국엔 정확한 내용까지 잘 이해하게 될 것이다. 

- 또한 앞서 언급했듯이, 우선순위 큐는 실제로는 단순히 힙 자료구조로 구현할 수 있다.
   거기다가 파이썬을 이용하면 힙을 직접 구현할 필요가 없다.
   '항상 가장 작은 값이 먼저 나온다'라는 특징을 지키면서,
   단일 데이터의 삽입과 삭제 연산을 O(logN)에 수행하는 heapq 라이브러리를 이용하면 된다.  
   또한 기본적으로 튜플의 첫 번째 원소인 '거리' 정보를 기준으로 해서 우선순위 큐를 구성하므로
   거리가 짧은 원소가 항상 먼저 나온다. 

- 다익스트라 최단 경로 알고리즘은 우선순위 큐를 이용한다는 점에서
  우선순위 큐를 필요로 하는 다른 문제 유형과도 흡사하다는 특징이 있다.
  그래서 최단 경로를 찾는 문제를 제외하고도 다른 문제에도 두루 적용되는 소스코드 형태라고
   이해할 수 있다. 
   예를 들어, 그래프 문제로 유명한 최소 신장 트리 문제를 풀 때에도 일부 알고리즘(Prim 알고리즘)
   의 구현이 다익스트라 알고리즘의 구현과 흡사하다는 특징이 있다.
   따라서 다익스트라 알고리즘을 바르게 이해할 수 있는 독자라면, 
   다른 고급 알고리즘도 이해할 가능성이 매우 높다. 


```
