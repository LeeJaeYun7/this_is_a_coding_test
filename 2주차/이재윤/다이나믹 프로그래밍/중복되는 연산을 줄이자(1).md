

```
현실 세계에는 다양한 문제가 있다. 그런데 이 중에서 컴퓨터를 활용해도 해결하기 어려운 문제는 무엇일까?
최적의 해를 구하기에 시간이 매우 많이 필요하거나 메모리 공간이 매우 많이 필요한 문제 등이 컴퓨터로도 해결하기 어려운 문제이다.
컴퓨터는 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이라는 점이 많은 제약을 발생시킨다.
그래서 우리는 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.

다만, 이런 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있다.
대표적인 방법이 바로 이번 장에서 다루는 다이나믹 프로그래밍 기법으로 동적 계획법이라고 표현하기도 한다.
먼저 다이나믹 프로그래밍의 기본적인 아이디어를 소개한 뒤에, 다이나믹 프로그래밍이 2가지 방식(탑다운과 보텀업)을 설명할 것이다.
특히, 다이나믹 프로그래밍을 위해 자주 사용되는 메모이제이션 기법까지 소개하겠다.

다이나믹 프로그래밍에 대해 알아보기 전에 기존의 알고리즘으로 해결하기 어려운 문제 중에서 다이나믹 프로그래밍으로 해결할 수 있는
문제를 살펴보자.

다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 피보나치 수열이 있다.
피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.
피보나치 수열은 다음과 같은 형태로 끝없이 이어진다.

수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현한다.
점화식이란 인접한 항들 사이의 관계식을 의미하는데, 예를 들어, 수열 {an}이 있을 때, 수열에서의 각 항을 an이라고 부른다고 가정하자.
우리는 점화식을 이용해 현재의 항을 이전의 항에 대한 식으로 표현할 수 있다.
예를 들어 피보나치 수열의 점화식은 다음과 같이 표현할 수 있다.

an+2 = f(an+1, an) = an+1 + an

이러한 점화식은 인접 3항간 점화식이라고 부르는데, 인접한 총 3개의 항에 대해서 식이 정의되기 때문이다.
수학과 친하지 않은 독자를 위해 좀 더 기본 예시를 가져와 보았다.
1, 2, 3, ...과 같이 이어지는 등차수열의 점화식은 다음과 같이 표현할 수 있다.

an+1 = f(an) = an + 1

결과적으로 앞서 언급했던 피보나치 수열에서는 첫 번째 항과 두 번째 항의 값이 모두 1이기 때문에
최종적으로 피보나치 수열을 나타낼 때에는 다음과 같이 정의할 수 있다.

an = an-1 + an-2, a1=1, a2=1

이를 해석하면 다음과 같다.
- n번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수
- 단, 1번째 피보나치 수 = 1, 2번째 피보나치 수 = 1

프로그래밍에서는 이러한 수열을 배열이나 리스트로 표현할 수 있다.
수열 자체가 여러 개의 수가 규칙에 따라서 배열된 형태를 의미하는 것이기 때문이다.
파이썬에서는 리스트 자료형이 이를 처리하고, C/C++와 자바에서는 배열을 이용하여 이를 처리한다.
리스트나 배열 모두 '연속된 많은 데이터'를 처리한다는 점은 동일하다.

그렇다면 이 점화식에 따라서 실제로 피보나치 수를 구하는 과정을 어떻게 표현할 수 있을까?
n번째 피보나치 수를 f(n)이라고 표현할 때 4번째 피보나치 수 f(4)를 구하려면,
다음과 같이 함수 f를 반복해서 호출할 것이다.

그런데 f(2)와 f(1)은 항상 1이기 때문에, f(1)이나 f(2)를 만났을 때는 호출을 정지한다.

수학적 점화식을 프로그래밍으로 표현하려면, 재귀 함수를 사용하면 간단하다
예시를 소스코드로 바꾸면 다음과 같다.

# 피보나치 함수(Fibonacci Function)를 재귀 함수로 구현
def fibo(x):
  if x == 1 or x == 2:
     return 1
  return finbo(x-1) + fibo(x-2)

print(fibo(4)) 


그런데 피보나치 수열의 소스코드를 이렇게 작성하면 심각한 문제가 생길 수 있다.
바로 f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다.
이 소스코드의 시간 복잡도는, 엄밀히 말하면 피보나치 수열의 정확한 시간 복잡도는 세타 표기법을 사용하여 0(1.618...N)으로 표현할 수 있다.
하지만 일반적으로는 빅오 표기법을 이용하여 O(2N)의 지수 시간이 소요된다고 표현한다.
예를 들어, N = 30이면 약 10억 가량의 연산을 수행해야 한다.
f(6)일때의 호출 과정을 그림으로 그려 확인해보자.

그림을 보면 동일한 함수가 반복적으로 호출되는 것을 알 수 있다.
이미 한 번 계산했지만, 계속 호출할때마다 계싼하는 것이다.
그림에서 f(3)이 몇 번 호출되었는가?
f(3)은 총 3번 호출되었다. 즉, f(n)에서 n이 커지면 커질수록 반복해서 호출하는 수가 많아진다.
예를 들어, f(100)을 계산하려면 얼마나 많은 연산을 해야 할까?
2의 10승을 약 1000이라고 했을 때, 약 1,000,000,000,000,000,000,000,000,000,000번이다.
아마 현대의 2진수 처리 방식을 가진 컴퓨터 구조에 기반한 시스템에서 연산을 수행했을 때,
우리의 수명이 다할 때까지 연산을 진행해도 답을 도출할 수 없을 것이다.

```

``````
