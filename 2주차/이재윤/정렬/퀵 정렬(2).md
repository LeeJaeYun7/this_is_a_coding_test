

```
다음은 파이썬의 장점을 살려 짧게 작성한 퀵 정렬 소스코드다.
전통 퀵 정렬의 분할 방식과는 조금 다른데, 피벗과 데이터를 비교하는 비교 연산 횟수가 증가하므로,
시간 면에서는 조금 비효율적이다.
하지만 더 직관적이고 기억하기 쉽다는 장점이 있다.

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
     if len(array) <= 1:
          return array

     pivot = array[0]
     tail = array[1:]

     left_side = [x for x in tail if x <= pivot]
     right_side = [x for x in tail if x > pivot]

     return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))

## 퀵 정렬의 시간 복잡도
- 이제 퀵 정렬의 시간 복잡도에 대해서 알아보자. 앞서 다룬 선택 정렬과 삽입 정렬의 시간 복잡도는 O(N2)이라고 하였다.
  선택 정렬과 삽입 정렬은 최악의 경우에도 항상 시간 복잡도 O(N2)을 보장한다.
  퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다. 앞서 다루었던 두 정렬 알고리즘에 비해 매우 빠른 편이다.

- 퀵 정렬이 어떻게 평균적으로 O(NlogN)의 시간 복잡도를 가지는지 궁금할 수 있는데,
  퀵 정렬의 시간 복잡도에 대한 증명은 초보자가 다루기에는 간단하지 않다.
  더불어 코딩 테스트를 목적으로 하는 경우, 퀵 정렬의 시간 복잡도 증명에 대하여 자세히 알지 못해도 큰 무리가 없다.
  따라서 책에서는 구체적인 증명보다는 직관적인 이해를 돕기 위한 설명에 초점을 맞추어 전개하고자 한다.

- 퀵 정렬에서 최선의 경우를 생각해보자. 피벗값의 위치가 변경되어 분할이 일어날 때마다 정확히 왼쪽 리스트와 오른쪽 리스트를
  절반씩 분할한다면 어떨까? 데이터의 개수가 8개라고 가정하고 다음과 같이 정확히 절반씩 나눈다고 도식화를 해보자.
  이 때, '높이'를 확인해보면, 데이터의 개수가 N개일 때, 높이는 약 logN이라고 판단할 수 있다.

- 다시 말해, 분할이 이루어지는 횟수가 기하급수적으로 감소하게 되는 것이다.
  일반적으로 컴퓨터 과학에서 log의 의미는 밑이 2인 로그를 의미한다.
  즉, log2N을 의미하며, 데이터의 개수 N이 1000일 때, log2N은 10가량이다.
  N = 1000일 때, log2N = 10은 상대적으로 매우 작은 수임을 이해할 수 있다.

- 데이터의 개수가 많을수록 차이는 매우 극명하게 드러난다.
  다음 표를 보면 데이터의 개수가 많을수록 퀵 정렬은 앞서 다루었던 선택 정렬, 삽입 정렬에 비해 압도적으로 빠르게 동작하리라 추측할 수 있다.
  표는 '평균 시간 복잡도'를 기준으로 각 정렬 알고리즘이 데이터의 개수에 따라 얼마나 많은 연산을 요구하는지를 보여주기 위해 작성되었으며,
  엄밀한 연산 횟수 비교는 아니다.

- 일반적으로 컴퓨터공학과 학부에서 퀵 정렬을 공부할 때에는 퀵 정렬의 수학적인 검증에 대해서도 공부하지만,
  코딩 테스트를 준비하는 과정에서는 그림을 통해 직관적인 이해를 하는 것만으로도 충분하다.
  다만, 퀵 정렬의 시간 복잡도에 대해 한 가지 기억해둘 점이 있다.
  바로 평균적으로 시간 복잡도가 O(NlogN)이지만, 최악의 경우 시간 복잡도가 O(N2)이라는 것이다.
  데이터가 무작위로 입력되는 경우, 퀵 정렬은 빠르게 동작할 확률이 높다.

- 하지만 이 책에서의 퀵 정렬처럼 리스트의 가장 왼쪽 데이터를 피벗으로 삼을 때, '이미 데이터가 정렬되어 있는 경우'에는 매우 느리게 동작한다.
  앞서 다룬 삽입 정렬은 이미 데이터가 정렬되어 있는 경우에는 매우 빠르게 동작한다고 했는데,
  퀵 정렬은 그와 반대된다고 이해할 수 있다.

- 그래서 실제로 C++와 같이 퀵 정렬을 기반으로 작성된 정렬 라이브러리를 제공하는 프로그래밍 언어들은 최악의 경우에도 시간 복잡도가 O(NlogN)
  이 되는 것을 보장할 수 있도록 피벗값을 설정할 때, 추가적인 로직을 더해준다. 파이썬 또한 마찬가지로 뒤에 설명할 기본 정렬 라이브러리를 이용하면
  O(NlogN)을 보장해주기 때무넹 여러분은 크게 걱정하지 않아도 된다. 구체적인 로직에 관한 내용은 책에서 자세히 다루지는 않도록 하겠다
   
```
