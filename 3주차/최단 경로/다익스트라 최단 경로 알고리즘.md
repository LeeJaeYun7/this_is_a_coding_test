

```

다익스트라 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때,
특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다.

다익스트라 최단 경로 알고리즘은 '음의 간선'이 없을 때 정상적으로 동작한다.
음의 간선이란 0보다 작은 값을 가지는 간선을 의미하는데,
현실 세계의 길(간선)은 음의 간선으로 표현되지 않으므로
다익스트라 알고리즘은 실제로 GPS 소프트웨어의 기본 알고리즘으로 채택되곤 한다.

다익스트라 최단 경로 알고리즘은 기본적으로 그리디 알고리즘으로 분류된다.
매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복하기 때문이다.
알고리즘의 원리를 간략히 설명하면 다음과 같다.

1) 출발 노드를 설정한다
2) 최단 거리 테이블을 초기화한다
3) 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다
4) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다
5) 위의 과정에서 3,4번을 반복한다.

다익스트라 알고리즘은 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리'
정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.
매번 현재 처리하고 있는 노드를 기준으로 주변 간선을 확인한다.
나중에 현재 처리하고 있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면
'더 짧은 경로도 있었네? 이제부터는 이 경로가 제일 짧은 경로야'라고 판단하는 것이다.
따라서 '방문하지 않은 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인'해 그 노드에 대하여
4번 과정을 수행한다는 점에서 그리디 알고리즘으로 볼 수 있다. 

다익스트라 알고리즘을 구현하는 방법은 2가지이다.
방법1. 구현하기 쉽지만 느리게 동작하는 코드
방법2. 구현하기에 조금 더 까다롭지만 빠르게 동작하는 코드

시험을 준비하는 여러분은 방법 2를 정확히 이해하고 구현할 수 있을 때까지 연습해야 한다.
특히 알고리즘 대회를 준비하는 독자라면 다익스트라 최단 겨올 알고리즘은 자다가도 일어나서 바로 코드를 작성할 수 있을 정도로 코드에 숙달되어 있어야 한다.
또한 최단 경로 알고리즘을 응용해서 풀 수 있는 고난이도 문제들이 많으므로 
방법 2를 이해하고 정확히 구현할 수 있다면
다양한 고난이도 문제를 만났을 때에도 도움을 얻을 수 있다. 

우선 먼저 다익스트라 알고리즘의 동작 원리를 살펴보자.
다음과 같은 그래프가 있을 때, 1번 노드에서 다른 모든 노드로 가는 최단 경로를 구하는 
문제를 생각해보자.

예시에서 출발 노드를 1이라 하겠다. 1번 노드에서 다른 모든 노드로의 최단 거리를 계산해볼 것이다. 초기 상태에서는 다른 모든 노드로 가는 최단 거리를 '무한'으로 초기화한다.
앞서 설명했듯이 코드로는 999,999,999 등의 값으로 설정할 수 있다. (약 10억)
자릿수가 헷갈리지 않도록 하기 위해서 987,654,321로 설정하기도 한다. 

그런데 파이썬에서 기본으로 1e9를 실수 자료형으로 처리하므로 모든 간선이 정수형으로 표현되는
문제에서는 int(1e9)로 초기화한다. 앞으로의 소스코드에서 '무한'이라는 값을 대입할 때는
int(1e9)를 사용하겠다. 

최단 거리 테이블이 의미하는 바는 1번 노드로부터 출발했을 때,
2번, 3번, 4번, 5번, 6번 노드까지 가기 위한 최단 경로가 각각 2, 3, 1, 2, 4라는 의미다.

다익스트라 최단 경로 알고리즘에서는 '방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택'하는 과정을 반복하는데, 이렇게 선택된 노드는 '최단 거리'가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않는다.

앞서 [step 6]까지의 모든 경우를 확인해보면, 실제로 한 번 선택된 노드는 최단 거리가 감소하지 않는다.  예를 들어 [step 2]에서는 4번 노드가 선택되어서 4번 노드를 거쳐서 이동할 수 있는 경로를 확인했다.  이후에 [step3]~[step6]이 진행되었으나, 4번 노드에 대한 최단 거리는 더 이상 감소하지 않았다. 다시 말해 다익스트라 알고리즘이 진행되면서 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다. 

그렇기 때문에, 사실 마지막 노드에 대해서는 해당 노드를 거쳐 다른 노드로 가는 경우를 확인할 필요가 없다. 예를 들어, 위의 예시에서 [step 6]을 수행할 때는 이미 나머지 5개 노드에 대한 최단 거리가 확정된 상태이므로 더 이상 테이블이 갱신될 수 없기 때문이다. 


```
