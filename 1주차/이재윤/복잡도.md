
```
복잡도는 알고리즘의 성능을 나타내는 척도이다.
복잡도는 시간 복잡도와 공간 복잡도로 나눌 수 있다
쉽게 말하면 시간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는지를 의미하고,
공간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미한다.

동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘이다.
참고로 이 책에서는 직관적인 이해를 위해 복잡도에 대한 정의를 간단히 설명하였으며,
엄밀한 정의를 이해하고 싶은 독자는 계산 복잡도 이론에 대해 공부해 보는 것을 추천한다.

복잡도를 측정함으로써 우리는 다음의 2가지를 계산할 수 있다.
(1) 시간 복잡도: 알고리즘을 위해 필요한 연산의 횟수
(2) 공간 복잡도: 알고리즘을 위해 필요한 메모리의 양

효율적인 알고리즘을 사용한다고 했을 때 보통 시간 복잡도와 공간 복잡도는 일종의 거래 관계가 성립한다.
메모리를 조금 더 많이 사용하는 대신에 반복되는 연산을 생략하거나 더 많은 정보를 관리하면서
계산의 복잡도를 줄일 수 있다.
이 때, 메모리를 더 소모하는 대신에 얻을 수 있는 시간적 이점이 매우 큰 경우가 종종 있다.
실제로 메모리를 더 많이 사용해서 시간을 비약적으로 줄이는 방법으로 메모이제이션(memoization)기법이 있는데,
이 내용은 8장에서 다룰 예정입니다. 

(1) 시간 복잡도
- 알고리즘 문제를 풀 때, 단순히 '복잡도'라고 하면 보통은 시간 복잡도를 의미한다.
  코딩 테스트를 처음 접하는 사람이 가장 어렵게 느끼는 부분이 '시간 제한'이다.
  흔히 '시간 제한'이라면 문제를 푸는 시간을 정한 듯하지만, 코딩 테스트에서는 작성한 프로그램이 
  모든 입력을 받아 이를 처리하고 실행 결과를 출력하는데까지 걸리는 시간을 의미한다.
  그래서 해당 시간 안에 동작하는 프로그램을 작성해야 정답 판정을 받을 수 있으며,
  프로그램을 비효율적으로 작성하여 시간 제한을 넘기면 '시간 초과(Time Limit Exceeded)'라는 메시지와 함께 
  오답으로 처리된다. 
  
- 시간 복잡도를 표현할 때는 빅오(Big-O)표기법을 사용한다. 엄밀한 정의는 아니지만, 빅오 표기법을 간단히 정의하자면,
  가장 빠르게 증가하는 항만을 고려하는 표기법이다. 
  다시 말해 함수의 상한만을 나타낸다. 
  예를 들어, N개의 데이터가 있을 때, 모든 데이터의 값을 더한 결과를 출력하는 프로그램을 생각해보자. 
  이 때, 우리는 합계를 저장할 하나의 변수를 선언한 뒤에 모든 데이터를 하나씩 확인하며 그 값을 합계 변수에 더해주는 식으로
  알고리즘을 작성할 수 있다. 
  
  다음 예제에서는 5개의 데이터를 받아 차례로 5회 더해준다.(N=5). 
  이 때 연산 횟수는 N에 비례하는 것을 알 수 있다. 물론 소스코드에서 summary 변수에 0의 값을 대입하는 연산도 있고,
  summary 변수의 값을 출력하는 부분도 있다.
  하지만 이런 연산의 횟수는 상대적으로 N이 커짐에 따라서 무시할 수 있을 정도로 작아질 것이다.
  따라서 본 소스코드에서 가장 영향력이 큰 부분은 N에 비례하는 연산을 수행하는 반복문 부분이므로,
  시간 복잡도를 O(N)이라고 표기한다. 
```

```
array = [3,5,1,2,4] 
summary = 0

for x in array:
    summary += x
    
print(summary)
```
```
이 책에서는 실행 결과를 다음 형식으로 표기한다.
15

몇 가지 예제를 더 살펴보자. 다음 소스코드는 어떤 시간 복잡도를 가질가?
a = 5
b = 7
print(a + b)

a와 b에 값을 대입하는 대입 연산과 출력 함수를 무시하고 보면, 이 소스코드의 연산 횟수는 O(1)이다.
단순히 ㅓ하기 연산 한 번이 수행되기 때문이다. 이는 상수 연산이므로 시간 복잡도는 O(1)로 표현할 수 있다.
이어서 다음은 어떤 시간 복잡도를 가질지 생각해보자. 
```
```
array = [3,5,1,2,4] # 5개의 데이터(N=5)

for i in array:
   for j in array:
     temp = i + j
     print(temp)
```
```
이 소스코드는 데이터의 개수(array 리스트 변수의 길이)가 N개일 때, O(N2)의 시간 복잡도를 가진다.
2중 반복문을 이용하여 각 원소에 대하여 다른 모든 원소에 대한 곱셈 결과를 매번 출력하고 있기 때문이다.
실은 간단한 2중 반복문이라서 NxN만큼의 연산이 필요하다는 것을 유추할 수 있다. 

하지만 모든 2중 반복문의 시간 복잡도가 O(N2)은 아니다. 
만약 소스코드가 내부적으로 다른 함수를 호출한다면 내부 함수의 시간 복잡도까지 고려해야 한다.
따라서 소스코드를 정확히 분석한 뒤에 시간 복잡도를 계산해야 한다는 점을 기억하자.

반면, 6장에서 배우게 될 내용 중 하나인 퀵 정렬의 평균 시간 복잡도는 O(NlogN)이지만,
최악의 경우 시간 복잡도는 O(N2)이다. 일반적으로 코딩 테스트에서는 최악의 경우에 대한 
연산 횟수가 가장 중요하다.

그러니 최악의 경우의 시간 복잡도를 우선적으로 고려해야 한다.

다음은 자주 등장하는 시간 복잡도 표인데, 위쪽에 있을수록 더 빠르다.
시간 복잡도에 따라서 부르는 명칭이 있는데, 예를 들어 O(1)는 '상수 시간', O(N)은 '선형 시간' 등으로 부른다. 

O(1) - 상수 시간(Constant time)
O(logN) - 로그 시간(Log time)
O(N) - 선형 시간
O(NlogN) - 로그 선형 시간
O(N2) - 이차 시간
O(N3) - 삼차 시간
O(2n) - 지수 시간
```
